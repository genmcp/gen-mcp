mcpFileVersion: 0.1.0
name: NETEDGE Network Diagnosis Tools
version: 0.0.1
runtime:
  transportProtocol: stdio
tools:

  - name: inspect_route
    title: Inspect Route (detailed)
    description: |
      Retrieve the Route resource and attempt to inspect the associated Service and Endpoints.
      This tool will try to extract the service name from the Route and then fetch the
      Service and Endpoints objects. Requires `oc` CLI and either `jq` or `python3` available
      on the gen-mcp host.
    inputSchema:
      type: object
      properties:
        name:
          type: string
          description: Route name
        namespace:
          type: string
          description: Route namespace
      required:
      - name
      - namespace
    invocation:
      cli:
        command: |
          ns="{namespace}"
          name="{name}"
          tmpf=$(mktemp)
          oc get route "$name" -n "$ns" -o json > "$tmpf" || exit 1
          echo "=== ROUTE ==="
          cat "$tmpf"
          svc=""
          if command -v jq >/dev/null 2>&1; then
            svc=$(jq -r '.spec.to.name // ""' "$tmpf")
          fi
          if [ -n "$svc" ]; then
            echo "=== SERVICE: $svc ==="
            oc get svc "$svc" -n "$ns" -o json || true
            echo "=== ENDPOINTS: $svc ==="
            oc get endpoints "$svc" -n "$ns" -o json || true
          else
            echo "Could not extract service name from route. Service-specific inspection skipped."
          fi
  - name: get_service_endpoints
    title: Get Service Endpoints
    description: Return Endpoints object for a Service
    inputSchema:
      type: object
      properties:
        service:
          type: string
          description: Service name
        namespace:
          type: string
          description: Namespace of the service
      required:
      - service
      - namespace
    invocation:
      cli:
        command: "oc get endpoints {service} -n {namespace} -o json"

  - name: query_prometheus
    title: Query Prometheus (range)
    description: Run a Prometheus `query_range` query and return JSON via the HTTP API. Automatically resolves the public Thanos route and injects an OAuth token when only an in-cluster `.svc` URL is provided.
    inputSchema:
      type: object
      properties:
        prometheus_url:
          type: string
          description: Base URL for Prometheus (e.g. http://prometheus:9090)
        query:
          type: string
          description: PromQL expression
        start:
          type: string
          description: RFC3339 or unix timestamp for start
        end:
          type: string
          description: RFC3339 or unix timestamp for end
        step:
          type: string
          description: Step duration (e.g. 30s)
      required:
      - prometheus_url
      - query
      - start
      - end
      - step
    invocation:
      cli:
        command: |
          prometheus_url="{prometheus_url}"
          query="{query}"
          start="{start}"
          end="{end}"
          step="{step}"
          jsonpath_expr="$(printf '\173.spec.host\175')"

          if [ -z "$prometheus_url" ] || [[ "$prometheus_url" == *".svc"* ]]; then
            route_host="$(oc -n openshift-monitoring get route thanos-querier -o jsonpath=\"$jsonpath_expr\" 2>/dev/null || true)"
            if [ -z "$route_host" ]; then
              echo "no accessible route found for thanos-querier; provide prometheus_url pointing to a reachable endpoint" >&2
              exit 1
            fi
            prometheus_url="https://$route_host"
          fi

          case "$prometheus_url" in
            http://*|https://*)
              base_url="$prometheus_url"
              ;;
            *)
              base_url="https://$prometheus_url"
              ;;
          esac

          token="$(oc whoami -t 2>/dev/null || true)"
          if [ -z "$token" ]; then
            echo "failed to obtain bearer token via oc whoami -t" >&2
            exit 1
          fi

          curl -sS -k --get \
            -H "Authorization: Bearer $token" \
            --data-urlencode "query=$query" \
            --data-urlencode "start=$start" \
            --data-urlencode "end=$end" \
            --data-urlencode "step=$step" \
            "$base_url/api/v1/query_range"

  - name: get_coredns_config
    title: Get CoreDNS ConfigMap
    description: Retrieve a CoreDNS ConfigMap (or any ConfigMap) by name and namespace.
    inputSchema:
      type: object
      properties:
        configmap:
          type: string
          description: ConfigMap name
        namespace:
          type: string
          description: Namespace
      required:
      - configmap
      - namespace
    invocation:
      cli:
        command: "oc get configmap {configmap} -n {namespace} -o yaml"

  - name: probe_dns_local
    title: Probe DNS from gen-mcp host
    description: Run a DNS query using local `dig` or `nslookup` on the gen-mcp host.
    inputSchema:
      type: object
      properties:
        server:
          type: string
          description: DNS server (IP or host)
        name:
          type: string
          description: DNS name to query
        type:
          type: string
          description: DNS record type (A, AAAA, TXT, etc.)
      required:
      - server
      - name
      - type
    invocation:
      cli:
        command: |
          s="{server}"
          n="{name}"
          t="{type}"
          if command -v dig >/dev/null 2>&1; then
            dig @$s $n $t +noall +answer || true
          else
            nslookup -type=$t $n $s || echo "dig/nslookup not available"
          fi

  - name: exec_dns_in_pod
    title: Exec DNS probe in ephemeral pod
    description: Run a short-lived pod that performs a DNS query using an approved image containing DNS tools.
      The cluster must allow the image to be pulled from the container registry.
    inputSchema:
      type: object
      properties:
        namespace:
          type: string
          description: Namespace to run the ephemeral pod in
        server:
          type: string
          description: DNS server to query
        name:
          type: string
          description: DNS name to query
        type:
          type: string
          description: DNS record type
      required:
      - namespace
      - server
      - name
      - type
    invocation:
      cli:
        command: |
          namespace="{namespace}"
          server="{server}"
          name="{name}"
          rtype="{type}"
          image="$NETEDGE_DNS_IMAGE"
          if [ -z "$image" ]; then
            image="registry.redhat.io/openshift4/network-tools-rhel9:latest"
          fi
          pod_name="netedge-dns-$RANDOM-$$"
          phase_jsonpath="$(printf '\\173.status.phase\\175')"

          trap 'oc -n "$namespace" delete pod "$pod_name" --ignore-not-found >/dev/null 2>&1 || true' EXIT INT TERM

          oc -n "$namespace" delete pod "$pod_name" --ignore-not-found >/dev/null 2>&1 || true

          overrides="$(printf '\173"spec":\173"securityContext":\173"runAsNonRoot":true,\"seccompProfile\":\173\"type\":\"RuntimeDefault\"\175\175,\"containers\":[\173\"name\":\"dns\",\"securityContext\":\173\"allowPrivilegeEscalation\":false,\"capabilities\":\173\"drop\":[\"ALL\"]\175\175\175]\175\175')"

          if ! oc -n "$namespace" run "$pod_name" \
            --image="$image" \
            --restart=Never \
            --command \
            --overrides "$overrides" \
            -- /bin/sh -c "dig @$server $name $rtype +noall +answer" >/dev/null; then
            echo "failed to create DNS probe pod" >&2
            exit 1
          fi

          for attempt in $(seq 1 24); do
            phase="$(oc -n "$namespace" get pod "$pod_name" -o "jsonpath=$phase_jsonpath" 2>/dev/null || true)"
            if [ "$phase" = "Succeeded" ]; then
              break
            fi
            if [ "$phase" = "Failed" ]; then
              oc -n "$namespace" logs "$pod_name" || true
              echo "DNS probe pod failed" >&2
              exit 1
            fi
            sleep 5
          done

          final_phase="$(oc -n "$namespace" get pod "$pod_name" -o "jsonpath=$phase_jsonpath" 2>/dev/null || true)"
          if [ "$final_phase" != "Succeeded" ]; then
            oc -n "$namespace" logs "$pod_name" || true
            echo "DNS probe pod did not complete successfully (phase=$final_phase)" >&2
            exit 1
          fi

          oc -n "$namespace" logs "$pod_name"

resources:
  - name: routes_all_namespaces
    title: List Routes (all namespaces)
    description: Enumerate all Route objects across namespaces so agents can discover available hosts and names before drilling in with `inspect_route`.
    inputSchema:
      type: object
      properties: {}
    invocation:
      cli:
        command: "oc get routes -A -o json"
